//
// Created by fufeng on 2024/1/24.
//

// 使用 Clang 编译器提供的 “-ast-dump” 选项，可以编译并打印出这段 C 代码对应的 AST 结构。完整的编译命令如下：
// clang -Xclang -ast-dump -fsyntax-only c_statement.c
// expression-ast-dump汇编.png
// AST 作为用于表示源代码语法结构的一种树形数据结构，语法分析器会将表达式中操作数的整体求值顺序映射到树的结构上。因此，当我们以后序遍历（LRD）的方式遍历这棵树时，便可以直接得到正确的表达式求值顺序。
// 对于上面的 AST 来说，由叶子结点组成的子树需要被最先求值，因此我们首先可以得到括号内加法表达式的计算结果 3。然后，该结果将作为叶子结点上的操作数，参与乘法运算符的计算，从而得到计算结果 9。接下来，除法运算符所在的子表达式经过求值，得到结果 0。最后，该值再作为最后一个加法运算符的操作数，与字面量值 9 相加，进而得到整个表达式的最终计算结果 9。
// 你可以看到，表达式提供了这样一种能力：能够让数据同时参与到多个操作符的不同计算过程中。而通过提供对运算符优先级与结合性的规则限制，表达式可以控制整个计算过程的有序进行。
int foo_expression(void) {
    return (1 + 2) * 3 + 4 / 5;
}

//语句（statement）是用来描述程序的基本构建块。和表达式不同，语句是构成 C 程序的最大粒度单元，在它的内部，可以包含有简单或复杂的表达式结构，但也可以不包含任何内容。除此之外，语句在执行时不返回任何结果，但可能会产生副作用。
//在 C 语言中，语句可以被分为复合语句、表达式语句、选择语句、迭代语句、跳转语句五种类型。但无论是哪种类型，语句都必须以分号结尾，并按从上到下的顺序依次执行。
//复合语句是指由花括号 “{}” 标记的一块区域。
int foo_statement(int x, int y) {  // 复合语句；
    int sum = x + y; // 表达式语句；
    if (sum < 0) {  // 复合语句；
        sum = -sum;  // 表达式语句；
    }
    return sum;
}

//选择语句 select_if_statement汇编.png
//通过汇编代码可以看到，变量 v 的值被存放在栈内存中地址为 rbp 寄存器的值减去 4 的位置上。程序使用多个标签（如 .L2、.L3 等），分别划分不同分支对应的处理逻辑，而分支的判断过程则是由指令 `cmp` 与条件跳转指令 `je` 与 `jne` 共同完成的。汇编代码和 C 代码的整体逻辑基本是一一对应的关系。因此，在这种情况下，为了尽量保持程序的执行性能，你可以将命中几率较大的条件语句放在较前的位置上。
int foo_select_if(int v) {
    if (v == 10 || v == 20) {
        return 1;
    } else if (v == 30 || v == 40) {
        return 2;
    } else if (v == 50 || v == 60) {
        return 3;
    } else {
        return 4;
    }
}

//选择语句 select_switch_statement汇编.png
//标注为红色的汇编代码会通过 `cmp` 指令，判断寄存器 eax 中的值，即变量 v 的值是否大于 60。若判断成立，则直接将程序跳转到标签 .L2 处，并将数字 4 作为返回值；若条件不成立，程序将继续执行。接下来，蓝色部分的代码会基于变量 v 的值，来产生一个用于参与后续运算符的 “token” 值。这个值的生成步骤如下所示：
//1. 将寄存器 edx 的值设为 1；
//2. 将寄存器 ecx 的值设为变量 v 的值；
//3. 将寄存器 rdx 中的值左移 v 位（值被扩展为 64 位）；
//4. 将此时寄存器 rdx 中的值移动到 rax 中留作待用。
//右侧虚线框内的代码，程序完成了对变量 v 的值的第一次筛选过程。这个过程很好理解，如果将其中第一行指令 `movabs` 的立即数操作数 1154047404513689600 以 64 位二进制的形式展开，你会发现其中只有第 50 和 60 位被置位。
//
//而第二行的 `and` 指令，会将这个超长的立即数与之前根据变量 v 的值进行移位而得来的 token 值进行“与”操作。若操作得到的结果不为 0，则表示 token 值的第 50 或 60 位肯定不为 0，即变量 v 的值为 50 或 60。否则，变量 v 的值则不符合该 case 语句的筛选条件。到这里，筛选的基本逻辑相信你已经清楚了。
//
//不过，通过“位映射”的方式进行分支筛选，并不能完美地覆盖所有情况。比如，当 case 语句的筛选值过大，无法使用寄存器来进行映射时，默认优化条件下，编译器会将 switch…case 的实现“回退”到与 if…else 类似的方式。也就是说，使用 `cmp` 指令与条件跳转指令来进行分支的筛选与转移。当然，具体采用哪种实现策略依据编译器的不同而有所不同。
int foo_select_switch(int v) {
    switch(v) {
        case 10:
        case 20: {
            return 1;
            break;
        }
        case 30:
        case 40: {
            return 2;
            break;
        }
        case 50:
        case 60: {
            return 3;
            break;
        }
        default: return 4;
    }
}

//除了上面介绍的 if…else 与 switch…case 语句实现方式外，在高优化等级下，编译器还可能会采用一种名为“跳表”的方式，来实现这两种条件选择语句。
// jump_select汇编.png
//标注为红色的汇编代码将变量 v 的值减去了选择语句中最小匹配条件的值，这里也就是 10。然后，程序通过 `cmp` 与 `ja` 指令，判断变量 v 的值是否超过了选择语句中最大匹配条件与最小匹配条件之间的差值，这里也就是 30。若是，则程序直接跳转到标签 .LBB0\_3 处，并返回数值 3。
//
//否则，程序就会使用跳表来寻找变量 v 的值对应的正确分支。**所谓跳表，即在一段连续内存中存放的，可用于辅助查找正确目标地址的地址信息**。在上面这个例子中，跳表从标签 .LJTI0\_0 处开始。在这段内存中，连续存放了筛选值 10 到 40 区间内，每一个整数值对应的正确分支处理地址。接下来的蓝色代码保存了当跳表第 0 项“命中”时，函数需要返回的值。
//
//假设在调用函数 foo 时，传入变量 v 的值为 20。虚线框中的 `jmp` 指令在执行时，会根据 v 的值在跳表中找到它所对应的正确分支地址。由于这里 rdi 寄存器中的值为 10（20 - 10），因此正确的分支处理地址便是跳表中第十项对应的值。这里可以看到，在 .LJTI0\_0 标签 +80 字节的位置（.quad 代表 8 字节数据）处，正对应着标签 .LBB0\_4 的地址。而该标签的位置，正是变量 v 为值 20 时的正确分支处理地址。
//
//除了上面提到的这些编译器在实现分支语句时使用的常用方式外，根据分支语句的具体情况，编译器还可能会采用某些针对特定形态代码的专用优化。而即使针对最“原始”的 `cmp` 加条件跳转语句组合这种实现方式，编译器也会根据 C 源代码的情况，适当使用“二分法”等优化策略，来加快条件的筛选过程。
int foo_select_switch_jump(int v) {
    switch(v) {
        case 10:
        case 20: {
            return 1;
            break;
        }
        case 30:
        case 40: {
            return 2;
            break;
        }
        default: return 4;
    }
}

//C 语言中的跳转语句主要指那些可以改变程序执行流程的语法结构，它们主要包括以下四种类型：
//
//- break 语句；
//- continue 语句；
//- return 语句；
//- goto 语句。

#include <stdio.h>
int foo_loop(int v) {
    do {
        printf("%d", v);
    } while(v--);
}

int main(void) {

    return 0;
}
