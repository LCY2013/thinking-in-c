//
// Created by fufeng on 2024/1/24.
//
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// c 算数、关系、位、赋值运算符
// 一个使用了加法运算符 “+” 的 C 语句。在它对应的汇编代码中，前两行代码分别从栈内存中将变量 x 与 y 的值放入到了寄存器 edx 与 eax 里。
// 紧接着，程序通过 `add` 机器指令计算这两个寄存器中的数字之和。
// 随后，通过 `mov` 指令，程序将计算得到的结果值从寄存器 eax 移动到了局部变量 arithmetic 对应的栈内存中。
// 这里采用的是 Intel 的汇编代码格式，因此，当该指令的源或目的操作数中涉及到某个具体的内存位置时，汇编代码中会出现类似 “DWORD PTR [rbp-8]” 的参数形式。
//对此，可以这样解读：将寄存器 rbp 中的值减去 8 得到的结果作为一个地址，然后在这个地址上读取/写入大小为 DWORD 的值。
// 在 Intel 体系中，一个 WORD 表示 16 位，一个 DWORD 为 32 位，而一个 QWORD 表示 64 位。
// 关系运算符大于号 “>” 对应汇编指令 `cmp`。
// 这个指令在被执行时，会首先比较变量 x 与 y 值的大小，并根据比较结果，动态调整 CPU 上 FLAGS 寄存器中的相应位。
// 这段代码中，汇编指令 `cmp` 的下一条汇编指令 `setg` 便会通过查看 FLAGS 寄存器中的 ZF 位是否为 0，且 SF 与 OF 位的值是否相等，来决定将寄存器 *al* 中的值置 1，还是置 0。而该寄存器中存放的数字值，便为变量 relational 的最终结果。
// ZF 位、SF 位、OF 位都是 FLAGS 寄存器中的常用标志位，用来反映当前指令执行后引起的 CPU 状态变化。
// 假设这里函数 foo 在调用时传入的值 x 为 3，y 为 2。那么，当 `cmp` 指令执行时，它首先会在 CPU 内部对这两个操作数进行隐式的减法运算，运算后得到结果 1。而 ZF、SF、OF 在这里都将被复位，而复位则代表着标志位所表示的状态为假。因此，FLAGS 寄存器的状态满足指令 `setg` 的置位条件（ZF=0 且 SF=OF），*al* 寄存器的值将被置 1。
// | 所对应的汇编指令是 `or`
void foo(int x, int y) {
    int arithmetic = x + y;
    bool relational = x > y;
    int bitwise = x | y;
    printf("%d %d %d",
           arithmetic,
           relational,
           bitwise);
}

// c 逻辑运算符
// 在 C 标准中，逻辑与运算符 “&&” 的语义是：如果它左右两侧的操作数都具有非零值，则产生计算结果值 1。而如果任一操作数为 0，则计算结果为 0。
// 逻辑与运算符并没有可与之直接对应的汇编指令。并且，为了满足“短路”要求，编译器在非优化的实现中通常会使用条件跳转指令，比如 `je`。`je` 指令会判断当前 FLAGS 寄存器中的标志位 ZF 是否为 1。若为 1，则会将程序执行直接跳转到给定标签所在地址上的指令。
// 上图中右侧输出的汇编代码里，程序会按顺序将位于栈内存中的变量 x 和 y 的值与数值 0 进行比较。若其中的某个比较结果相等，程序执行将会直接跳转到标签 “.L2” 的所在位置。在这里，值 0 会被直接放入寄存器 *eax*。而若变量 x 与 y 的值判断均不成立，则值 1 会被放入该寄存器。紧接着，标签 “.L3” 中的指令将接着执行。
// 在使用高编译优化等级时，编译器还可能会采用下面这种方式来实现该运算符。这里新的汇编指令： `test` 、`setne` 和 `movzx` 。
// `test` 指令的执行方式与 `cmp` 类似，只不过它会对传入的两个操作数做隐式的“与”操作，而非减法操作。在操作完成后，根据计算结果，指令会相应地修改 FLAGS 寄存器上的 SF、ZF 以及 PF 标志位。另外的 `setne` 指令则与 `setg` 指令类似，该指令将在 ZF 为 0 时把传入的寄存器置位，否则将其复位。最后的指令 `movzx` 实际上是 `mov` 指令的一种变体。这个指令将数据从源位置移动到目标位置后，会同时对目标位置上的数据进行零扩展（Zero Extension）。
// 了解了这些，我们就可以来尝试理解**编译器在高优化等级下对逻辑与运算符的实现方式**：首先，通过 `test` 指令，程序可以判断参数 x 与 y 是否为非零值。若为非零值，则相应的寄存器会被指令 `setne` 置位。在这种情况下，寄存器 *al* 与 *sil* 中便存放有用于表示变量 x 与 y 是否为零的布尔数字值 0 或 1。接下来，通过数据移动指令，寄存器 *sil* 中的值被移动到寄存器 *esi* 中。最后的 `and` 指令又会对 x 与 y 的布尔数字值再次进行与操作，得到的最终结果将被存放在目的寄存器，即 *esi* 中。
// 这种实现方式大量减少了对栈内存以及条件跳转指令的使用，使得程序减少了访问内存时产生的延迟，以及由于分支预测失败而导致的 CPU 周期浪费，从而执行性能得到了提升。
// 可以看到的是，在使用高编译优化等级的情况下，C 标准中逻辑与操作符的“短路”特性并没有体现出来，程序实际上同时对参数 x 与 y 的值进行了判断**。**而这也正是因为 **C 语言的 “as-if” 性质给予了编译器更多的优化空间**。C 标准中规定，除去几种特殊的情况外，在不影响一个程序的外部可观测行为的情况下，编译器可以不遵循 C 标准中对执行模型的规定，而是采用其特定的实现方式，优化程序的性能。
void foo1(int x, int y) {
    bool logical = x && y;
    printf("%d", logical);
}

// c 成员访问运算符
// 对于取地址运算符 “&”，实际上它一般会直接对应到名为 `lea` 的汇编指令。这个指令的全称为 “Load Effective Address”，顾名思义，它主要用来将操作数作为地址，并将这个地址以值的形式传送到其他位置。比如，上面代码中的 `lea` 指令将寄存器 rbp 中的值减去 16 后，直接存放到寄存器 rax 中，而此时该寄存器中的值就是局部变量 n 在栈上的地址。
// 而解引用运算符 “*”的行为与取地址运算符完全相反。当需要对位于某个地址上的值进行传送时，可以直接使用 `mov` 指令。第一条 `mov` 指令将变量 n\_ptr 的值传送到了寄存器 rax 中。随后，第二条 `mov` 指令将 rax 寄存器中的值作为地址，并将该地址上的值以 DWORD，即 32 位值（对应 `int` 类型）的形式传送到 eax 寄存器中。最后，第三条 `mov` 指令将此时 eax 寄存器中的结果值传送到了变量 m 在栈内存上的存储位置。
void foo2() {
    int n = 10;
    int* n_ptr = &n;
    int m = *n_ptr;
    printf("%d %p %d", n, n_ptr, m);
}

// c 其他运算符
// `sizeof` 运算符是一个编译期运算符，这意味着编译器仅通过静态分析就能够将给定参数的大小计算出来。因此，在最终生成的汇编代码中，我们不会看到 `sizeof` 运算符对应于任何汇编指令。相反，运算符在编译过程中得到的计算结果值，将会以字面量值的形式直接“嵌入”到汇编代码中使用。你可以从上图中右侧红框内的汇编代码看到，C 代码 `sizeof(int)` 的计算结果 4 直接作为了 `mov` 指令的一个操作数。
//至于强制类型转换运算符呢，其实也很好理解。这里，我们将变量 n 的值类型由原来的 `size_t` 转换为了 `short`。当 `mov` 指令将变量 n 的值移动到变量 f 所在的内存区域时，它仅移动了这个值从低位开始一个 WORD，即 16 位大小的部分。至于其他类型之间的转换过程，可以简单理解成对同一块数据在不同机器指令下的不同“解读”方式。
//在高编译优化等级下，成员访问运算符与强制类型转换运算符的实现方式并没有发生本质的变化。而与其他运算符类似的是，编译器会减少对栈内存的使用。同时，基于更强的静态分析能力，编译器甚至可以提前推算出某些变量的取值，并省去在程序运行过程中再进行类型转换的过程，从而进一步提升程序的运行时性能。
void foo3() {
    size_t n = sizeof(int);
    short f = (short) n;
    printf("%zd %d", n, f);
}

//通常来说，算数、关系、位、赋值运算符的实现在大多数情况下，都会直接一一对应到特定的汇编指令上；
//逻辑运算符的实现方式则有些不同，它会首先借助 `test` 、 `cmp` 等指令，来判断操作数的状态，并在此基础上再进行相应的数值转换过程；
//在成员访问运算符中，取地址运算符一般对应于汇编指令 `lea` ，解引用运算符则可直接使用 `mov` 指令来实现；
//对于其他运算符，`sizeof` 运算符会在编译时进行求值，强制类型转换运算符则直接对应于不同指令对同一块数据的不同处理方式。
int main(void) {
    foo(1,3);
    foo1(1,3);
    foo2();
    foo3();

    return 0;
}
